<script>
    // ============================================
    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ù„ÙˆØ§Ù† (Ù‡ÙˆÙŠØ© Ù†Ø§ÙØ³)
    // ============================================
    const chartTheme = {
      text: '#334155', 
      grid: '#cbd5e1', 
      primary: '#006C67', // Ø£Ø®Ø¶Ø± Ù†Ø§ÙØ³
      secondary: '#C5A466', // Ø°Ù‡Ø¨ÙŠ
      accent: '#ef4444', // Ø£Ø­Ù…Ø± Ù„Ù„ØªÙ…ÙŠÙŠØ²
      lines: '#1e293b'
    };

    // ============================================
    // Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø©
    // ============================================
    function toArabicDigits(input) {
      if(!input) return "";
      const map = "Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©";
      return input.toString().replace(/[0-9]/g, (d) => map[d]);
    }
    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    const choose = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const shuffle = (array) => array.sort(() => Math.random() - 0.5);

    // ============================================
    // 1. Ø¯ÙˆØ§Ù„ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© (SVG) - ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«
    // ============================================

    // --- Ø±Ø³Ù… Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø¨Ø§Ù„Ø®Ø·ÙˆØ· ---
    function renderLineGraphSVG(data, title, yLabel) {
      const w = 350, h = 220;
      const m = { t: 40, r: 30, b: 40, l: 50 };
      const innerW = w - m.l - m.r;
      const innerH = h - m.t - m.b;
      
      // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù…Ø­ÙˆØ± Ø§Ù„ØµØ§Ø¯ÙŠ
      const maxVal = Math.max(...data.map(d => d.value)) + 5;
      const stepX = innerW / (data.length - 1);

      // Ù†Ù‚Ø§Ø· Ø§Ù„Ø®Ø·
      const points = data.map((d, i) => {
        return {
          x: m.l + (i * stepX),
          y: m.t + innerH - ((d.value / maxVal) * innerH),
          val: d.value,
          lbl: d.label
        };
      });

      // Ù…Ø³Ø§Ø± Ø§Ù„Ø®Ø·
      const pathD = "M " + points.map(p => `${p.x},${p.y}`).join(" L ");

      // Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù€ SVG
      let svgContent = `
        <line x1="${m.l}" y1="${m.t}" x2="${m.l}" y2="${h - m.b}" stroke="${chartTheme.grid}" stroke-width="2"/>
        <line x1="${m.l}" y1="${h - m.b}" x2="${w - m.r}" y2="${h - m.b}" stroke="${chartTheme.grid}" stroke-width="2"/>
        
        <path d="${pathD}" fill="none" stroke="${chartTheme.primary}" stroke-width="3" />
      `;

      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ù†ØµÙˆØµ
      points.forEach(p => {
        svgContent += `
          <circle cx="${p.x}" cy="${p.y}" r="5" fill="white" stroke="${chartTheme.primary}" stroke-width="2"/>
          <text x="${p.x}" y="${h - m.b + 20}" text-anchor="middle" font-size="12" fill="${chartTheme.text}">${p.lbl}</text>
          <text x="${p.x}" y="${p.y - 10}" text-anchor="middle" font-size="11" font-weight="bold" fill="${chartTheme.text}">${toArabicDigits(p.val)}</text>
        `;
      });

      return `<div class="bg-white p-3 rounded-xl border border-slate-200 flex flex-col items-center">
                <h3 class="text-sm font-bold text-[#006C67] mb-2">${title}</h3>
                <svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
                  ${svgContent}
                  <text x="${m.l - 10}" y="${m.t}" text-anchor="end" font-size="10" fill="#64748b">${yLabel}</text>
                </svg>
              </div>`;
    }

    // --- Ø±Ø³Ù… Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø¨Ø§Ù„Ù†Ù‚Ø§Ø· (Dot Plot / Line Plot) ---
    function renderDotPlotSVG(data, title) {
      const w = 350, h = 180;
      const m = { t: 30, r: 20, b: 40, l: 20 };
      const innerW = w - m.l - m.r;
      const stepX = innerW / (data.length + 1);

      let svgContent = `
        <line x1="${m.l}" y1="${h - m.b}" x2="${w - m.r}" y2="${h - m.b}" stroke="${chartTheme.grid}" stroke-width="3" stroke-linecap="round"/>
        <path d="M ${m.l} ${h-m.b} L ${m.l+5} ${h-m.b-3} M ${m.l} ${h-m.b} L ${m.l+5} ${h-m.b+3}" stroke="${chartTheme.grid}" stroke-width="2"/>
        <path d="M ${w-m.r} ${h-m.b} L ${w-m.r-5} ${h-m.b-3} M ${w-m.r} ${h-m.b} L ${w-m.r-5} ${h-m.b+3}" stroke="${chartTheme.grid}" stroke-width="2"/>
      `;

      data.forEach((d, i) => {
        const x = m.l + (i + 1) * stepX;
        const yBase = h - m.b;
        
        // Ø§Ù„Ø±Ù‚Ù… Ø¹Ù„Ù‰ Ø®Ø· Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯
        svgContent += `<text x="${x}" y="${yBase + 25}" text-anchor="middle" font-size="14" font-weight="bold" fill="${chartTheme.text}">${toArabicDigits(d.val)}</text>`;
        
        // Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø§Ø· (X)
        for (let k = 0; k < d.count; k++) {
          const y = yBase - 15 - (k * 18);
          // Ø±Ø³Ù… Ø´ÙƒÙ„ X
          const size = 5;
          svgContent += `
            <line x1="${x-size}" y1="${y-size}" x2="${x+size}" y2="${y+size}" stroke="${chartTheme.primary}" stroke-width="2.5" />
            <line x1="${x+size}" y1="${y-size}" x2="${x-size}" y2="${y+size}" stroke="${chartTheme.primary}" stroke-width="2.5" />
          `;
        }
      });

      return `<div class="bg-white p-3 rounded-xl border border-slate-200 flex flex-col items-center">
                <h3 class="text-sm font-bold text-[#006C67] mb-2">${title}</h3>
                <svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
                  ${svgContent}
                </svg>
              </div>`;
    }

    // --- Ø±Ø³Ù… Ø§Ù„Ø²ÙˆØ§ÙŠØ§ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© (Ø§Ù„Ù…ØªØªØ§Ù…Ø©ØŒ Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„Ø©ØŒ Ø§Ù„Ù…ØªÙ‚Ø§Ø¨Ù„Ø©) ---
    function renderComplexAngleSVG(type, angle1, angle2, missingIndex) {
      const size = 200, cx = 100, cy = 150, len = 80;
      let svgInner = "";
      
      if (type === "comp") { 
        // Ù…ØªØªØ§Ù…ØªØ§Ù† (Ø²Ø§ÙˆÙŠØ© Ù‚Ø§Ø¦Ù…Ø© Ù…Ù‚Ø³ÙˆÙ…Ø©)
        // Ø®Ø· Ø£ÙÙ‚ÙŠ ÙˆØ±Ø£Ø³ÙŠ (Ù‚Ø§Ø¦Ù…Ø©)
        svgInner += `<path d="M ${cx} ${cy} L ${cx+len} ${cy} L ${cx} ${cy} L ${cx} ${cy-len}" stroke="${chartTheme.lines}" stroke-width="3" fill="none"/>`;
        // Ø§Ù„Ø´Ø¹Ø§Ø¹ Ø§Ù„Ù‚Ø§Ø·Ø¹
        const rad = (angle1 * Math.PI) / 180;
        const rx = cx + len * Math.cos(rad);
        const ry = cy - len * Math.sin(rad);
        svgInner += `<line x1="${cx}" y1="${cy}" x2="${rx}" y2="${ry}" stroke="${chartTheme.secondary}" stroke-width="2"/>`;
        // Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        svgInner += `<rect x="${cx}" y="${cy-15}" width="15" height="15" fill="none" stroke="${chartTheme.accent}" stroke-width="1.5"/>`;
        
        // Ø§Ù„Ù†ØµÙˆØµ
        const txt1 = missingIndex === 1 ? "Ø³Â°" : toArabicDigits(angle1)+"Â°";
        const txt2 = missingIndex === 2 ? "Ø³Â°" : toArabicDigits(angle2)+"Â°";
        svgInner += `<text x="${cx+30}" y="${cy-10}" font-size="12">${txt1}</text>`;
        svgInner += `<text x="${cx+10}" y="${cy-40}" font-size="12">${txt2}</text>`;

      } else if (type === "supp") {
        // Ù…ØªÙƒØ§Ù…Ù„ØªØ§Ù† (Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ… Ù…Ù‚Ø³ÙˆÙ…)
        svgInner += `<line x1="${cx-len}" y1="${cy}" x2="${cx+len}" y2="${cy}" stroke="${chartTheme.lines}" stroke-width="3"/>`;
        // Ø§Ù„Ø´Ø¹Ø§Ø¹
        const rad = (angle1 * Math.PI) / 180;
        const rx = cx + len * Math.cos(-rad); // negative because SVG y goes down
        const ry = cy + len * Math.sin(-rad);
        svgInner += `<line x1="${cx}" y1="${cy}" x2="${rx}" y2="${ry}" stroke="${chartTheme.secondary}" stroke-width="2"/>`;
        
        // Ø§Ù„Ù†ØµÙˆØµ
        const txt1 = missingIndex === 1 ? "Ø³Â°" : toArabicDigits(angle1)+"Â°";
        const txt2 = missingIndex === 2 ? "Ø³Â°" : toArabicDigits(angle2)+"Â°";
        // Ù…ÙˆØ§Ø¶Ø¹ ØªÙ‚Ø±ÙŠØ¨ÙŠØ© Ù„Ù„Ù†Øµ
        svgInner += `<text x="${cx+30}" y="${cy-15}" font-size="12">${txt1}</text>`;
        svgInner += `<text x="${cx-30}" y="${cy-15}" font-size="12">${txt2}</text>`;

      } else if (type === "vert") {
        // Ù…ØªÙ‚Ø§Ø¨Ù„ØªØ§Ù† Ø¨Ø§Ù„Ø±Ø£Ø³ (X shape)
        // Ø®Ø· 1
        svgInner += `<line x1="${cx-60}" y1="${cy-60}" x2="${cx+60}" y2="${cy+60}" stroke="${chartTheme.lines}" stroke-width="3"/>`;
        // Ø®Ø· 2
        svgInner += `<line x1="${cx-60}" y1="${cy+60}" x2="${cx+60}" y2="${cy-60}" stroke="${chartTheme.lines}" stroke-width="3"/>`;
        
        // Ø§Ù„Ù†ØµÙˆØµ (ÙÙˆÙ‚ ÙˆØªØ­Øª)
        const txt1 = missingIndex === 1 ? "Ø³Â°" : toArabicDigits(angle1)+"Â°"; // ÙÙˆÙ‚
        const txt2 = missingIndex === 2 ? "Ø³Â°" : toArabicDigits(angle1)+"Â°"; // ØªØ­Øª
        svgInner += `<text x="${cx}" y="${cy-40}" text-anchor="middle" font-size="14" fill="${chartTheme.primary}">${txt1}</text>`;
        svgInner += `<text x="${cx}" y="${cy+50}" text-anchor="middle" font-size="14" fill="${chartTheme.primary}">${txt2}</text>`;
      }

      return `<div class="flex justify-center my-4"><svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
        ${svgInner}
        <circle cx="${cx}" cy="${cy}" r="4" fill="${chartTheme.lines}"/>
      </svg></div>`;
    }

    // Ø¯ÙˆØ§Ù„ Ø±Ø³Ù… Ù‚Ø¯ÙŠÙ…Ø© Ù„Ù„Ø£Ø¹Ù…Ø¯Ø© ÙˆØ§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª (Ù…ÙˆØ¬ÙˆØ¯Ø© Ù„Ø¯ÙŠÙƒ Ù„ÙƒÙ† Ù†Ø¶Ø¹Ù‡Ø§ Ù„Ù„Ø§ÙƒØªÙ…Ø§Ù„)
    function renderBarGraphSVG(data, title, yLabel) {
        // ... (Ù†ÙØ³ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ù„Ù„Ø£Ø¹Ù…Ø¯Ø©)
        const width = 320, height = 220;
        const m = { top: 30, right: 20, bottom: 40, left: 40 };
        const cw = width - m.left - m.right, ch = height - m.top - m.bottom;
        const maxV = Math.max(...data.map((d) => d.value));
        const bw = cw / data.length;
        let bars = "", labels = "";
        data.forEach((d, i) => {
          const bh = (d.value / maxV) * ch;
          const x = m.left + i * bw + bw * 0.1;
          const y = m.top + ch - bh;
          const w = bw * 0.8;
          bars += `<rect x="${x}" y="${y}" width="${w}" height="${bh}" fill="${chartTheme.primary}" rx="2"/>`;
          bars += `<text x="${x + w / 2}" y="${y - 5}" text-anchor="middle" font-size="11" font-weight="bold" fill="${chartTheme.text}">${toArabicDigits(d.value)}</text>`;
          labels += `<text x="${x + w / 2}" y="${height - 10}" text-anchor="middle" font-size="11" fill="${chartTheme.text}">${d.name}</text>`;
        });
        return `<div class="bg-white p-2 rounded border border-slate-100 flex flex-col items-center"><h3 class="text-sm font-bold text-[#006C67] mb-1">${title}</h3><svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}"><line x1="${m.left}" y1="${m.top}" x2="${m.left}" y2="${height - m.bottom}" stroke="#cbd5e1" stroke-width="2"/><line x1="${m.left}" y1="${height - m.bottom}" x2="${width - m.right}" y2="${height - m.bottom}" stroke="#cbd5e1" stroke-width="2"/>${bars}${labels}</svg></div>`;
    }
    function renderPieChartSVG(data, title) {
        // ... (Ù†ÙØ³ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ù„Ù„Ù‚Ø·Ø§Ø¹Ø§Øª)
         const size = 200, center = size / 2, r = 70;
        const total = data.reduce((s, d) => s + d.value, 0);
        let start = 0, paths = "", legend = "";
        const colors = [chartTheme.primary, chartTheme.secondary, '#3b82f6'];
        data.forEach((d, i) => {
          const angle = (d.value / total) * 360;
          const end = start + angle;
          const x1 = center + r * Math.cos((Math.PI * start) / 180);
          const y1 = center + r * Math.sin((Math.PI * start) / 180);
          const x2 = center + r * Math.cos((Math.PI * end) / 180);
          const y2 = center + r * Math.sin((Math.PI * end) / 180);
          const large = angle > 180 ? 1 : 0;
          const color = colors[i % colors.length];
          paths += `<path d="M ${center} ${center} L ${x1} ${y1} A ${r} ${r} 0 ${large} 1 ${x2} ${y2} Z" fill="${color}" stroke="white" stroke-width="2"/>`;
          legend += `<div class="flex items-center gap-2 text-xs mb-1 text-slate-700"><span class="inline-block w-3 h-3 rounded-full" style="background-color:${color};"></span><span>${d.name} (${toArabicDigits(Math.round((d.value / total) * 100))}Ùª)</span></div>`;
          start = end;
        });
        return `<div class="bg-white p-4 rounded border border-slate-100 flex flex-col items-center"><h3 class="text-sm font-bold text-[#006C67] mb-2">${title}</h3><svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">${paths}</svg><div class="mt-2 text-right">${legend}</div></div>`;
    }

    // ============================================
    // 2. Ù…Ù†Ø·Ù‚ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (Logic) - Ø§Ù„Ù…Ø­Ø¯Ø«
    // ============================================
    const domains = [
      // ... (Ù†ÙØ³ Ø§Ù„Ù…Ø¬Ø§Ù„Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©ØŒ Ø³Ø£Ø±ÙƒØ² Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙÙŠ generateQuestion)
      // ØªØ£ÙƒØ¯ Ø£Ù† Ù…ØµÙÙˆÙØ© Ø§Ù„Ù…Ø¬Ø§Ù„Ø§Øª domains Ù…ÙˆØ¬ÙˆØ¯Ø© Ù„Ø¯ÙŠÙƒ ÙƒÙ…Ø§ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚
      {
          id: "statistics",
          name: "Ø§Ù„Ø¥Ø­ØµØ§Ø¡ ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª",
          skills: [
            { id: "central", name: "Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ù†Ø²Ø¹Ø© Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ©", desc: "Ø§Ù„Ù…ØªÙˆØ³Ø·ØŒ Ø§Ù„ÙˆØ³ÙŠØ·ØŒ Ø§Ù„Ù…Ù†ÙˆØ§Ù„ØŒ Ø§Ù„Ù…Ø¯Ù‰" },
            { id: "bar-graph", name: "Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ©", desc: "ØªÙØ³ÙŠØ± ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª" },
            { id: "pie-chart", name: "Ø§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª Ø§Ù„Ø¯Ø§Ø¦Ø±ÙŠØ©", desc: "Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù†Ø³Ø¨ ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª" },
            { id: "line-graph", name: "Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø¨Ø§Ù„Ø®Ø·ÙˆØ·", desc: "ØªØªØ¨Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø¨Ø± Ø§Ù„Ø²Ù…Ù†" },
            { id: "scatter", name: "Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø¨Ø§Ù„Ù†Ù‚Ø§Ø·", desc: "ØªÙØ³ÙŠØ± ØªÙƒØ±Ø§Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (X)" },
          ],
        },
        {
          id: "geometry",
          name: "Ø§Ù„Ù‡Ù†Ø¯Ø³Ø©",
          skills: [
            { id: "shapes", name: "Ø§Ù„Ø£Ø´ÙƒØ§Ù„ ÙˆØ§Ù„Ù…Ø¬Ø³Ù…Ø§Øª", desc: "Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø«Ù†Ø§Ø¦ÙŠØ© ÙˆØ«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯" },
            { id: "angles", name: "Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø²ÙˆØ§ÙŠØ§", desc: "Ø§Ù„Ù…ØªØªØ§Ù…Ø©ØŒ Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„Ø©ØŒ Ø§Ù„Ù…ØªÙ‚Ø§Ø¨Ù„Ø© Ø¨Ø§Ù„Ø±Ø£Ø³" }, // ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØµÙ
            { id: "symmetry", name: "Ø§Ù„ØªÙ…Ø§Ø«Ù„", desc: "Ù…Ø­Ø§ÙˆØ± Ø§Ù„ØªÙ…Ø§Ø«Ù„ Ù„Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©" },
          ],
        },
        // ... Ø¨Ù‚ÙŠØ© Ø§Ù„Ù…Ø¬Ø§Ù„Ø§Øª (Ø£Ø¹Ø¯Ø§Ø¯ØŒ Ù‚ÙŠØ§Ø³ØŒ Ø¬Ø¨Ø±) ÙƒÙ…Ø§ Ù‡ÙŠ
        {
          id: "numbers", name: "Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ ÙˆØ§Ù„Ø¹Ù…Ù„ÙŠØ§Øª", skills: [
             { id: "place-value", name: "Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ù†Ø²Ù„ÙŠØ©", desc: "ØªØ­Ø¯ÙŠØ¯ Ù…Ù†Ø²Ù„Ø© Ø§Ù„Ø±Ù‚Ù… ÙˆÙ‚ÙŠÙ…ØªÙ‡" },
             { id: "compare-nums", name: "Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯", desc: "Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø±Ù…ÙˆØ²" },
             { id: "round-nums", name: "ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯", desc: "Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ Ù„Ø£Ù‚Ø±Ø¨ Ø¹Ø´Ø±Ø© ÙˆÙ…Ø¦Ø© ÙˆØ£Ù„Ù" },
             { id: "four-ops", name: "Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ÙŠØ©", desc: "Ø§Ù„Ø¬Ù…Ø¹ØŒ Ø§Ù„Ø·Ø±Ø­ØŒ Ø§Ù„Ø¶Ø±Ø¨ØŒ ÙˆØ§Ù„Ù‚Ø³Ù…Ø©" },
             { id: "frac-compare", name: "Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙƒØ³ÙˆØ±", desc: "Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙƒØ³ÙˆØ± Ø§Ù„Ø§Ø¹ØªÙŠØ§Ø¯ÙŠØ©" },
             { id: "frac-add-sub", name: "Ø¬Ù…Ø¹ ÙˆØ·Ø±Ø­ Ø§Ù„ÙƒØ³ÙˆØ±", desc: "Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ³ÙˆØ± Ù…ØªØ´Ø§Ø¨Ù‡Ø© Ø§Ù„Ù…Ù‚Ø§Ù…" },
             { id: "frac-simplify", name: "ØªØ¨Ø³ÙŠØ· Ø§Ù„ÙƒØ³ÙˆØ±", desc: "Ø¥ÙŠØ¬Ø§Ø¯ Ø£Ø¨Ø³Ø· ØµÙˆØ±Ø© Ù„Ù„ÙƒØ³Ø±" },
          ]
        },
        {
          id: "measurement", name: "Ø§Ù„Ù‚ÙŠØ§Ø³", skills: [
            { id: "length", name: "ÙˆØ­Ø¯Ø§Øª Ø§Ù„Ø·ÙˆÙ„", desc: "Ø§Ù„ØªØ­ÙˆÙŠÙ„ (Ù…ØŒ Ø³Ù…ØŒ ÙƒÙ…) ÙˆØ§Ù„Ù…Ø­ÙŠØ·" },
            { id: "time", name: "Ø§Ù„Ø²Ù…Ù† ÙˆØ§Ù„ÙˆÙ‚Øª", desc: "Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø³Ø§Ø¹Ø© ÙˆØ­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¯Ø©" },
            { id: "mass", name: "Ø§Ù„ÙƒØªÙ„Ø©", desc: "Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠÙ† Ø§Ù„Ø¬Ø±Ø§Ù… ÙˆØ§Ù„ÙƒÙŠÙ„ÙˆØ¬Ø±Ø§Ù…" },
            { id: "volume", name: "Ø§Ù„Ø­Ø¬Ù… ÙˆØ§Ù„Ø³Ø¹Ø©", desc: "Ø­Ø¬Ù… Ø§Ù„Ù…Ø¬Ø³Ù…Ø§Øª ÙˆØ³Ø¹Ø© Ø§Ù„Ø³ÙˆØ§Ø¦Ù„" },
            { id: "area", name: "Ø§Ù„Ù…Ø³Ø§Ø­Ø©", desc: "Ù‚ÙˆØ§Ù†ÙŠÙ† Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙˆØ§Ù„Ù…Ø³ØªØ·ÙŠÙ„" },
          ]
        },
        {
          id: "algebra", name: "Ø§Ù„Ø¬Ø¨Ø± ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø·", skills: [
            { id: "one-step", name: "Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª", desc: "Ø­Ù„ Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø¬Ù…Ø¹ ÙˆØ§Ù„Ø·Ø±Ø­ Ø§Ù„Ø¨Ø³ÙŠØ·Ø©" },
            { id: "patterns", name: "Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø¹Ø¯Ø¯ÙŠØ©", desc: "Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© ÙˆØ¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù†Ù…Ø·" },
          ]
        }
    ];

    function generateQuestion(skillId) {
      let qText = "", qSvg = null, qType = "text", qAns = "", qHint = "", qChoices = null;

      switch (skillId) {
        // --- 1. Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø¨Ø§Ù„Ø®Ø·ÙˆØ· (Ø¬Ø¯ÙŠØ¯) ---
        case "line-graph":
          const days = ["Ø§Ù„Ø³Ø¨Øª", "Ø§Ù„Ø£Ø­Ø¯", "Ø§Ù„Ø§Ø«Ù†ÙŠÙ†", "Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡", "Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡"];
          const temps = days.map(d => ({ label: d, value: randInt(20, 45) }));
          qSvg = renderLineGraphSVG(temps, "Ø¯Ø±Ø¬Ø§Øª Ø§Ù„Ø­Ø±Ø§Ø±Ø© Ø®Ù„Ø§Ù„ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹", "Ø¯Ø±Ø¬Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø©");
          
          // Ø§Ø®ØªÙŠØ§Ø± ÙŠÙˆÙ… Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù†Ù‡
          const targetDay = choose(temps);
          qText = `Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø¨Ø§Ù„Ø®Ø·ÙˆØ·ØŒ Ù…Ø§ Ù‡ÙŠ Ø¯Ø±Ø¬Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø© ÙŠÙˆÙ… ${targetDay.label}ØŸ`;
          qAns = toArabicDigits(targetDay.value);
          qType = "numeric";
          qHint = "Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙŠÙˆÙ… ÙÙŠ Ø§Ù„Ø£Ø³ÙÙ„ØŒ Ø«Ù… Ø§ØµØ¹Ø¯ Ù„Ù„Ø®Ø· ÙˆØ§Ù‚Ø±Ø£ Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„.";
          break;

        // --- 2. Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø¨Ø§Ù„Ù†Ù‚Ø§Ø· (Ø¬Ø¯ÙŠØ¯) ---
        case "scatter":
          // Ø¨ÙŠØ§Ù†Ø§Øª: Ø¹Ø¯Ø¯ Ø§Ù„ÙƒØªØ¨ Ø§Ù„Ù…Ù‚Ø±ÙˆØ¡Ø© (Ø§Ù„Ù‚ÙŠÙ… Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø·)
          const values = [1, 2, 3, 4, 5]; 
          // Ø§Ù„ØªÙƒØ±Ø§Ø± (Ø¹Ø¯Ø¯ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª X)
          const dataPoints = values.map(v => ({ val: v, count: randInt(1, 5) }));
          qSvg = renderDotPlotSVG(dataPoints, "Ø¹Ø¯Ø¯ Ø§Ù„ÙƒØªØ¨ Ø§Ù„ØªÙŠ Ù‚Ø±Ø£Ù‡Ø§ Ø§Ù„Ø·Ù„Ø§Ø¨");

          // Ù†ÙˆØ¹ÙŠÙ† Ù…Ù† Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
          if (Math.random() > 0.5) {
            // Ø³Ø¤Ø§Ù„ Ù…Ø¨Ø§Ø´Ø±: ÙƒÙ… Ø·Ø§Ù„Ø¨ Ù‚Ø±Ø£ X ÙƒØªØ¨ØŸ
            const t = choose(dataPoints);
            qText = `ÙƒÙ… Ø·Ø§Ù„Ø¨Ø§Ù‹ Ù‚Ø±Ø£ ${toArabicDigits(t.val)} ÙƒØªØ¨ØŸ (Ø§Ø­Ø³Ø¨ Ø¹Ø¯Ø¯ Ø¥Ø´Ø§Ø±Ø§Øª X)`;
            qAns = toArabicDigits(t.count);
          } else {
            // Ø³Ø¤Ø§Ù„: Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ø£ÙƒØ«Ø± ØªÙƒØ±Ø§Ø±Ø§Ù‹ØŸ
            const maxCount = Math.max(...dataPoints.map(d => d.count));
            const maxVal = dataPoints.find(d => d.count === maxCount).val;
            qText = `Ù…Ø§ Ù‡Ùˆ Ø¹Ø¯Ø¯ Ø§Ù„ÙƒØªØ¨ Ø§Ù„Ø£ÙƒØ«Ø± Ù‚Ø±Ø§Ø¡Ø© Ø¨ÙŠÙ† Ø§Ù„Ø·Ù„Ø§Ø¨ØŸ (Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø£Ø·ÙˆÙ„)`;
            qAns = toArabicDigits(maxVal);
          }
          qType = "numeric";
          break;

        // --- 3. ØªØ·ÙˆÙŠØ± Ø§Ù„Ø²ÙˆØ§ÙŠØ§ (Ù…ØªÙ‚Ø¯Ù…) ---
        case "angles":
          // Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª: Ù…ØªØªØ§Ù…Ø©ØŒ Ù…ØªÙƒØ§Ù…Ù„Ø©ØŒ Ù…ØªÙ‚Ø§Ø¨Ù„Ø© Ø¨Ø§Ù„Ø±Ø£Ø³
          const types = ["comp", "supp", "vert"];
          const selectedType = choose(types);
          let a1, a2;

          if (selectedType === "comp") { // Ù…ØªØªØ§Ù…Ø© (90)
            a1 = randInt(20, 70);
            a2 = 90 - a1;
            qSvg = renderComplexAngleSVG("comp", a1, a2, 2); // Ù†Ø®ÙÙŠ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø«Ø§Ù†ÙŠØ©
            qText = `Ø§Ù„Ø²Ø§ÙˆÛŒØªØ§Ù† Ù…ØªØªØ§Ù…ØªØ§Ù† (Ù…Ø¬Ù…ÙˆØ¹Ù‡Ù…Ø§ Ù©Ù Â°). Ø£ÙˆØ¬Ø¯ Ù‚ÙŠÙ…Ø© Ø³:`;
            qAns = toArabicDigits(a2);
          } else if (selectedType === "supp") { // Ù…ØªÙƒØ§Ù…Ù„Ø© (180)
            a1 = randInt(40, 140);
            a2 = 180 - a1;
            qSvg = renderComplexAngleSVG("supp", a1, a2, 2);
            qText = `Ø§Ù„Ø²Ø§ÙˆÛŒØªØ§Ù† Ù…ØªÙƒØ§Ù…Ù„ØªØ§Ù† (Ø¹Ù„Ù‰ Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…). Ø£ÙˆØ¬Ø¯ Ù‚ÙŠÙ…Ø© Ø³:`;
            qAns = toArabicDigits(a2);
          } else { // Ù…ØªÙ‚Ø§Ø¨Ù„Ø© Ø¨Ø§Ù„Ø±Ø£Ø³ (Ù…ØªØ³Ø§ÙˆÙŠØ©)
            a1 = randInt(30, 150);
            a2 = a1;
            qSvg = renderComplexAngleSVG("vert", a1, a2, 2);
            qText = `Ø§Ù„Ø²Ø§ÙˆÛŒØªØ§Ù† Ù…ØªÙ‚Ø§Ø¨Ù„ØªØ§Ù† Ø¨Ø§Ù„Ø±Ø£Ø³. Ø£ÙˆØ¬Ø¯ Ù‚ÙŠÙ…Ø© Ø³:`;
            qAns = toArabicDigits(a1);
          }
          qType = "numeric";
          break;

        // --- Ø¨Ù‚ÙŠØ© Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª (ÙƒÙ…Ø§ Ù‡ÙŠ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ù„ÙƒÙ† Ù…Ø®ØªØµØ±Ø© Ù‡Ù†Ø§ Ù„Ù„ÙˆØ¶ÙˆØ­) ---
        case "bar-graph":
          const bData = [{name:"Ø£Ø­Ù…Ø¯",value:randInt(5,20)}, {name:"Ø®Ø§Ù„Ø¯",value:randInt(5,20)}, {name:"Ø³Ø¹Ø¯",value:randInt(5,20)}];
          qSvg = renderBarGraphSVG(bData, "Ø§Ù„Ù†Ù‚Ø§Ø·", "Ø§Ù„Ø¹Ø¯Ø¯");
          const bTarget = choose(bData);
          qText = `ÙƒÙ… Ø¹Ø¯Ø¯ Ù†Ù‚Ø§Ø· Ø§Ù„Ø·Ø§Ù„Ø¨ ${bTarget.name}ØŸ`;
          qAns = toArabicDigits(bTarget.value);
          qType = "numeric";
          break;
        case "pie-chart":
          const pData = [{name:"Ù…Ø§Ø¡",value:50},{name:"Ø¹ØµÙŠØ±",value:30},{name:"Ù„Ø¨Ù†",value:20}];
          qSvg = renderPieChartSVG(pData, "Ø§Ù„Ù…Ø´Ø±ÙˆØ¨Ø§Øª");
          qText = "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ù…Ø´Ø±ÙˆØ¨ Ø§Ù„Ø£ÙƒØ«Ø± ØªÙØ¶ÙŠÙ„Ø§Ù‹ØŸ";
          qAns = "Ù…Ø§Ø¡"; qType="mcq"; qChoices=["Ù…Ø§Ø¡","Ø¹ØµÙŠØ±","Ù„Ø¨Ù†"];
          break;
        case "central":
          let set = [randInt(2,9), randInt(2,9), randInt(2,9)];
          while((set[0]+set[1]+set[2])%3 !== 0) set[2]++; // Ù„Ù„Ù…ØªÙˆØ³Ø·
          qText = `Ø£ÙˆØ¬Ø¯ Ø§Ù„Ù…ØªÙˆØ³Ø· Ø§Ù„Ø­Ø³Ø§Ø¨ÙŠ Ù„Ù„Ø£Ø¹Ø¯Ø§Ø¯: ${set.map(toArabicDigits).join('ØŒ ')}`;
          qAns = toArabicDigits((set[0]+set[1]+set[2])/3);
          qType = "numeric";
          break;
        
        // ... (ÙŠÙ…ÙƒÙ†Ùƒ Ù†Ø³Ø® Ø¨Ù‚ÙŠØ© Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù€ case Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚: place-value, four-ops... Ø¥Ù„Ø®)
        // Ø³Ø£Ø¶ÙŠÙ Ù…Ø«Ø§Ù„ ÙˆØ§Ø­Ø¯ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ù…Ù„ Ø§Ù„ÙƒÙˆØ¯
        case "place-value":
          const num = randInt(100, 9999);
          qText = `Ù…Ø§ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ù†Ø²Ù„ÙŠØ© Ù„Ù„Ø±Ù‚Ù… Ù¥ ÙÙŠ Ø§Ù„Ø¹Ø¯Ø¯ ${toArabicDigits(num)} (Ø¨Ø§ÙØªØ±Ø§Ø¶ ÙˆØ¬ÙˆØ¯Ù‡)ØŸ`;
          // Ù„ØªØ¨Ø³ÙŠØ· Ø§Ù„Ù…Ø«Ø§Ù„ØŒ Ø³Ø£Ø¹ÙŠØ¯ Ø³Ø¤Ø§Ù„Ø§Ù‹ Ø¨Ø³ÙŠØ·Ø§Ù‹ØŒ ÙŠÙØ¶Ù„ Ù†Ø³Ø® Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ø§Ù„ÙƒØ§Ù…Ù„
          qText = `Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ ${toArabicDigits(num)} Ø¨Ø§Ù„ØµÙŠØºØ© Ø§Ù„Ù„ÙØ¸ÙŠØ©. (Ø³Ø¤Ø§Ù„ ØªØ¬Ø±ÙŠØ¨ÙŠ)`;
          qAns = num.toString();
          break;

        default: // Ù„Ø£ÙŠ Ù…Ù‡Ø§Ø±Ø© Ù„Ù… ÙŠØªÙ… ØªØ¹Ø±ÙŠÙÙ‡Ø§ Ø¨Ø¹Ø¯
           // Ù‡Ù†Ø§ Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ù„Ø¨Ù‚ÙŠØ© Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª (Ø£Ø¹Ø¯ Ù†Ø³Ø® Ø§Ù„Ù€ switch Ø§Ù„Ù‚Ø¯ÙŠÙ… Ù‡Ù†Ø§ Ù„Ø¨Ù‚ÙŠØ© Ø§Ù„Ø­Ø§Ù„Ø§Øª)
           // Ù‡Ø°Ø§ Ù…Ø¬Ø±Ø¯ "Fallback"
           const n1 = randInt(1,10), n2 = randInt(1,10);
           qText = `Ø£ÙˆØ¬Ø¯ Ù†Ø§ØªØ¬: ${toArabicDigits(n1)} Ã— ${toArabicDigits(n2)}`;
           qAns = toArabicDigits(n1*n2);
           qType = "numeric";
      }

      return { text: qText, svg: qSvg, type: qType, ans: qAns.toString(), hint: qHint, choices: qChoices };
    }

    // ============================================
    // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© (Ù†ÙØ³ Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø³Ø§Ø¨Ù‚)
    // ============================================
    let currentDomainId = "numbers";
    let currentSkillId = "place-value";
    let stats = { total: 0, correct: 0 };

    document.addEventListener("DOMContentLoaded", () => {
      // Ø²Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„
      const enterBtn = document.getElementById("enter-btn");
      if(enterBtn) {
        enterBtn.addEventListener("click", () => {
          document.getElementById("welcome-section").classList.add("hidden");
          document.getElementById("main-app").classList.remove("hidden");
          loadDomainTabs();
          loadSkillsList(); // ØªØ£ÙƒØ¯ Ù…Ù† ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        });
      }

      // Ø²Ø± Ø§Ù„ØªØ­Ù‚Ù‚
      const form = document.getElementById("answer-form");
      if(form) {
        form.addEventListener("submit", (e) => {
          e.preventDefault();
          checkAnswer();
        });
      }
    });

    function loadDomainTabs() {
      const tabsContainer = document.getElementById("domains-tabs");
      if(!tabsContainer) return;
      tabsContainer.innerHTML = "";
      domains.forEach(d => {
         const btn = document.createElement("button");
         btn.textContent = d.name;
         btn.className = `px-4 py-2 rounded-lg text-sm font-bold transition-all border border-transparent ${currentDomainId === d.id ? 'bg-[#006C67] text-white shadow-md' : 'bg-white text-slate-600 hover:bg-slate-50 border-slate-200'}`;
         btn.onclick = () => { currentDomainId = d.id; loadDomainTabs(); loadSkillsList(); };
         tabsContainer.appendChild(btn);
      });
      // ØªØ­Ø¯ÙŠØ« Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª
      loadSkillsList();
    }

    function loadSkillsList() {
      const listContainer = document.getElementById("skills-list");
      if(!listContainer) return;
      const domain = domains.find(d => d.id === currentDomainId);
      document.getElementById("domain-title").textContent = domain.name;
      
      listContainer.innerHTML = "";
      domain.skills.forEach(s => {
        const btn = document.createElement("button");
        btn.className = `w-full text-right px-4 py-3 rounded-lg text-sm transition-all mb-1 border-r-4 ${currentSkillId === s.id ? 'bg-[#E6F4F3] border-[#006C67] text-[#004D49] font-bold' : 'border-transparent text-slate-600 hover:bg-slate-50'}`;
        btn.innerHTML = `<div class="font-bold">${s.name}</div><div class="text-xs opacity-70 mt-1 font-normal">${s.desc}</div>`;
        btn.onclick = () => { currentSkillId = s.id; loadSkillsList(); resetStats(); loadQuestion(); };
        listContainer.appendChild(btn);
      });
      // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø¨Ø§Ø´Ø±Ø© Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
      loadQuestion();
    }

    function loadQuestion() {
      const qData = generateQuestion(currentSkillId);
      const qContainer = document.getElementById("question-text");
      const hintEl = document.getElementById("hint-text");
      const mcqContainer = document.getElementById("mcq-container");
      const inputContainer = document.getElementById("input-container");
      const ansInput = document.getElementById("answer-input");
      
      document.getElementById("feedback-correct").classList.add("hidden");
      document.getElementById("feedback-wrong").classList.add("hidden");
      ansInput.value = "";
      document.getElementById("current-correct-answer").dataset.correctAnswer = qData.ans;

      qContainer.innerHTML = "";
      if(qData.svg) qContainer.innerHTML += qData.svg;
      qContainer.innerHTML += `<div class="mt-4">${qData.text}</div>`;

      if(qData.hint) {
         hintEl.textContent = "ğŸ’¡ ØªÙ„Ù…ÙŠØ­: " + qData.hint;
         hintEl.classList.remove("hidden");
      } else {
         hintEl.classList.add("hidden");
      }

      if(qData.type === "mcq") {
         inputContainer.classList.add("hidden");
         mcqContainer.classList.remove("hidden");
         mcqContainer.innerHTML = "";
         qData.choices.forEach(ch => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.textContent = ch;
            btn.className = "px-4 py-3 bg-slate-50 border border-slate-200 rounded-xl text-slate-700 font-bold hover:bg-[#006C67] hover:text-white transition-all shadow-sm";
            btn.onclick = () => {
               ansInput.value = ch;
               checkAnswer();
            };
            mcqContainer.appendChild(btn);
         });
      } else {
         inputContainer.classList.remove("hidden");
         mcqContainer.classList.add("hidden");
         ansInput.focus();
      }
    }

    function resetStats() {
       stats.total = 0; stats.correct = 0;
       updateStatsUI();
    }

    function updateStatsUI() {
       document.getElementById("stat-total").textContent = toArabicDigits(stats.total);
       document.getElementById("stat-correct").textContent = toArabicDigits(stats.correct);
       const pct = stats.total === 0 ? 0 : Math.round((stats.correct/stats.total)*100);
       document.getElementById("stat-percent").textContent = toArabicDigits(pct) + "Ùª";
    }

    function checkAnswer() {
       const userAns = document.getElementById("answer-input").value.trim();
       const correctAns = document.getElementById("current-correct-answer").dataset.correctAnswer;
       if(!userAns) return;

       stats.total++;
       const normUser = userAns.replace(/[Ù -Ù©]/g, d => "Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©".indexOf(d));
       const normCorr = correctAns.replace(/[Ù -Ù©]/g, d => "Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©".indexOf(d));
       
       let isCorrect = (normUser == normCorr); 
       if(!isCorrect && !isNaN(normUser) && !isNaN(normCorr)) {
          isCorrect = (Number(normUser) === Number(normCorr));
       }

       if(isCorrect) {
          stats.correct++;
          document.getElementById("feedback-correct").classList.remove("hidden");
          document.getElementById("feedback-wrong").classList.add("hidden");
       } else {
          document.getElementById("feedback-wrong").classList.remove("hidden");
          document.getElementById("feedback-correct").classList.add("hidden");
          document.getElementById("feedback-wrong-text").textContent = "Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰! Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù‡ÙŠ: " + correctAns;
       }
       
       updateStatsUI();
       if(isCorrect) setTimeout(loadQuestion, 2000);
    }
</script>